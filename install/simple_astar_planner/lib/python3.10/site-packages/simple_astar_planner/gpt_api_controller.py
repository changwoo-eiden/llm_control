#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import json
import time

import rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile, ReliabilityPolicy, DurabilityPolicy
from std_msgs.msg import String

from openai import OpenAI

from simple_astar_planner.navigator import Navigator
from simple_astar_planner.takephoto import PhotoTaker
from simple_astar_planner.detection import DetectionAction  # detection ì•¡ì…˜

from simple_astar_planner.prompt_branch.plan_prompt import make_plan_chain


api_key = os.getenv("OPENAI_API_KEY")
client = OpenAI(api_key=api_key)

def safe_float(val, default=0.0):

    try:
        return default if val is None else float(val)
    except (TypeError, ValueError):
        return default

def _validate_and_normalize_sequence(seq: list) -> list:

    cleaned = []
    for i, step in enumerate(seq, start=1):
        if not isinstance(step, dict) or "action" not in step:
            raise ValueError(f"{i}ë²ˆì§¸ ìŠ¤í…ì´ ì˜ëª»ë¨: {step}")
        act = step["action"]

        def pick(key, default=None):
            val = step.get(key, default)
            return val

        if act == "goto":
            x = pick("x"); y = pick("y"); yaw = pick("yaw")
            if x is None or y is None or yaw is None:
                raise ValueError(f"{i}ë²ˆì§¸ gotoì— x,y,yawê°€ í•„ìš”í•©ë‹ˆë‹¤: {step}")
            cleaned.append({"action": "goto", "x": float(x), "y": float(y), "yaw": float(yaw)})

        elif act == "wait":
            dur = pick("duration")
            if dur is None:
                raise ValueError(f"{i}ë²ˆì§¸ waitì— durationì´ í•„ìš”í•©ë‹ˆë‹¤: {step}")
            cleaned.append({"action": "wait", "duration": float(dur)})

        elif act == "photo":
            cleaned.append({"action": "photo"})

        elif act == "detection":
            cls = pick("class") or pick("arg") or pick("target")
            if cls is None or not isinstance(cls, str) or not cls.strip():
                raise ValueError(f"{i}ë²ˆì§¸ detectionì— class/arg/target ì¤‘ í•˜ë‚˜ê°€ í•„ìš”í•©ë‹ˆë‹¤: {step}")
            timeout = pick("timeout", 5.0)
            timeout = 5.0 if timeout is None else float(timeout)
            cleaned.append({"action": "detection", "class": cls.strip(), "timeout": timeout})

        else:
            raise ValueError(f"{i}ë²ˆì§¸ ìŠ¤í… action ì•Œ ìˆ˜ ì—†ìŒ: {act}")

    return cleaned


class GPTAPIController(Node):
    def __init__(self):
        super().__init__("gpt_api_controller")

        qos = QoSProfile(depth=1)
        qos.reliability = ReliabilityPolicy.RELIABLE
        qos.durability = DurabilityPolicy.TRANSIENT_LOCAL

        self.map_info = None
        self.sub_map = self.create_subscription(String, "/map_anchors", self.map_callback, qos)
        self.get_logger().info("ğŸ›°ï¸ Waiting for /map_anchors data...")

        self.navigator = Navigator()
        self.photo = PhotoTaker(self.navigator)
        self.detector = DetectionAction(
            node=self,
            detections_topic="/detections_vision",
            image_topic="/bcr_bot/kinect_camera/image_raw",
            yolo_node_name="yolo_v5_ros2_node",
            yolo_pkg="my_perception",
            yolo_exec="yolo_v5_ros2_node",
            model_path="/home/changwoo/yolov5/yolov5s.pt",
            device="cuda",             # "cpu" | "cuda"
            conf_thres=0.35,
            iou_thres=0.45,
            backend="auto",
            keep_yolo_running=False,
            max_wait_yolo_ready=5.0,
        )
        self.detector.last_detected = False   # ë§ˆì§€ë§‰ íƒì§€ ê²°ê³¼ ì €ì¥ìš©
        self.plan_chain = make_plan_chain()
        self.get_logger().info("ğŸ§© Few-shot Plan Prompt Loaded")


    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def map_callback(self, msg: String):
        try:
            self.map_info = json.loads(msg.data)
            self.get_logger().info("âœ… Received /map_anchors update")
        except Exception as e:
            self.get_logger().error(f"Failed to parse /map_anchors: {e}")

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def ask_gpt_for_plan(self, user_command: str) -> dict:
        if self.map_info is None:
            self.get_logger().warn("âŒ Map info not received yet.")
            return {}

        bboxes = self.map_info["bboxes"]
        anchors = self.map_info["anchors"]

        forbidden = json.dumps({"forbidden_bboxes": bboxes}, ensure_ascii=False)
        anchor_info = json.dumps({"anchors": anchors}, ensure_ascii=False)

        try:
            result = self.plan_chain.invoke({
                "user_command": f"{user_command}\n\nì§€ë„ì •ë³´:\n{forbidden}\n{anchor_info}"
            })
            content = result.content
            self.get_logger().info(f"ğŸ“¥ GPT ì‘ë‹µ(Structured): {content}")
            return json.loads(content)

        except Exception as e:
            self.get_logger().error(f"âŒ GPT ìš”ì²­ ì‹¤íŒ¨: {e}")
            return {}
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def run_sequence(self, sequence: list):
        for idx, step in enumerate(sequence, start=1):
            act = step["action"]

            if act == "goto":
                x = safe_float(step.get("x"))
                y = safe_float(step.get("y"))
                yaw = safe_float(step.get("yaw", 0.0))

                self.get_logger().info(f"[{idx}] ğŸ¯ GOTO: x={x:.3f}, y={y:.3f}, yaw={yaw:.3f}")
                self.navigator.goto(x, y, yaw=yaw)

            elif act == "wait":
                raw_dur = step.get("duration")
                duration = 0.0 if raw_dur is None else float(raw_dur)
                self.get_logger().info(f"[{idx}] â¸ WAIT: {duration:.2f}s")
                end = time.monotonic() + duration
                while rclpy.ok() and time.monotonic() < end:
                    rclpy.spin_once(self, timeout_sec=0.1)

            elif act == "photo":
                self.get_logger().info(f"[{idx}] ğŸ“¸ PHOTO")
                self.photo.take_photo()

            elif act == "detection":
                cls = step.get("class", "")
                raw_timeout = step.get("timeout")
                timeout = 5.0 if raw_timeout is None else float(raw_timeout)
                self.get_logger().info(f"[{idx}] ğŸ” DETECTION: class='{cls}', timeout={timeout:.2f}s")
                found, info = self.detector.detect(
                    target_class=cls,
                    timeout_sec=timeout,
                    prefer_param="class_filter",
                    auto_spawn_yolo=True
                )
                self.detector.last_detected = found  # âœ… ê²°ê³¼ ì €ì¥
                if found:
                    self.get_logger().info(f"[{idx}] âœ… DETECTED: {cls}")
                else:
                    self.get_logger().info(f"[{idx}] ğŸ™… NOT FOUND: {cls}")

            else:
                self.get_logger().warn(f"[{idx}] â“ Unknown action: {act}")
    
    def run_plan_recursive(self, plan):
    # 1ï¸âƒ£ setup ì‹¤í–‰
        setup_seq = plan.get("setup", [])
        if setup_seq:
            self.get_logger().info("ğŸš€ Setup ë‹¨ê³„ ì‹¤í–‰ ì‹œì‘")
            self.run_sequence(setup_seq)

    # 2ï¸âƒ£ detection ê²°ê³¼ í™•ì¸
        detected = getattr(self.detector, "last_detected", False)
        self.get_logger().info(f"ğŸ” Detection result: {detected}")

    # 3ï¸âƒ£ ë¶„ê¸° ì„ íƒ
        branches = plan.get("branches", {})
        branch_seq = branches.get("if_true" if detected else "if_false", [])

        for step in branch_seq:
        # case 1ï¸âƒ£ ì¼ë°˜ action step
            if "action" in step:
                self.run_sequence([step])
        # case 2ï¸âƒ£ branch ì¤‘ì²© êµ¬ì¡°ë©´ ì¬ê·€ ì‹¤í–‰
            elif "branches" in step:
                self.get_logger().info("ğŸ” Nested branch ë°œê²¬ â€” ì¬ê·€ ì‹¤í–‰")
                self.run_plan_recursive(step)
            else:
                self.get_logger().warn(f"âš ï¸ ì•Œ ìˆ˜ ì—†ëŠ” step êµ¬ì¡°: {step}")


    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def ask_and_run_once(self):
        deadline = time.time() + 5.0
        while rclpy.ok() and self.map_info is None and time.time() < deadline:
            rclpy.spin_once(self, timeout_sec=0.1)
        if self.map_info is None:
            self.get_logger().warn("âš ï¸ ì•„ì§ /map_anchors ë¥¼ ëª» ë°›ì•˜ìŠµë‹ˆë‹¤. ê·¸ë˜ë„ ì§„í–‰í•©ë‹ˆë‹¤.")

        user_cmd = input("ğŸ‘‰ ëª…ë ¹ì„ ì…ë ¥í•˜ì„¸ìš”: ").strip()
        if not user_cmd:
            print("âŒ ëª…ë ¹ì´ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤. ì¢…ë£Œí•©ë‹ˆë‹¤.")
            return

        plan_data = self.ask_gpt_for_plan(user_cmd)
        if not plan_data or "plan" not in plan_data:
            print("âŒ ìœ íš¨í•œ ê³„íšì„ ë°›ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ì¢…ë£Œí•©ë‹ˆë‹¤.")
            return

        plan = plan_data["plan"]

        # 1ï¸âƒ£ setup ë¨¼ì € ì‹¤í–‰
        setup_seq = plan.get("setup", [])
        if setup_seq:
            self.get_logger().info("ğŸš€ Setup ë‹¨ê³„ ì‹¤í–‰ ì‹œì‘")
            self.run_sequence(setup_seq)

        # 2ï¸âƒ£ detection ê²°ê³¼ í™•ì¸ í›„ ë¶„ê¸°
        detected = getattr(self.detector, "last_detected", False)
        self.get_logger().info(f"ğŸ” Detection result: {detected}")

        branches = plan.get("branches", {})
        branch_seq = branches["if_true"] if detected else branches["if_false"]

        if branch_seq:
            branch_name = "if_true" if detected else "if_false"
            self.get_logger().info(f"ğŸš¦ Branch '{branch_name}' ì‹¤í–‰ ì‹œì‘")
            for step in branch_seq:
                if "action" in step:
                    self.run_sequence([step])
                elif "branches" in step:
                    self.run_plan_recursive(step)

        else:
            self.get_logger().info("âš™ï¸ Branch ì‹œí€€ìŠ¤ê°€ ë¹„ì–´ ìˆìŒ.")

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def main():
    rclpy.init()
    node = GPTAPIController()
    try:
        node.ask_and_run_once()
    finally:
        try:
            node.navigator.destroy_node()
        except Exception:
            pass
        node.destroy_node()
        rclpy.shutdown()


if __name__ == "__main__":
    main()
